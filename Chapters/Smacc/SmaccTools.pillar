!! Debugging and Testing

I believe what you want is to start debugging a parser with some script and then stepping through it.

The SmaCC debugger only gets activated if the SmaCC code is in the execution context. So, if you do not have it yet you can “Step to debugger”.

For example:
- Try debugging:
	==JavaParser parse: 'public class A {}'==
- Then from the window menu, choose “Step to debugger” / “SmaCC”

+SmaCC Special Debugger available in Moose.>file://figures/SmaccSpecialDebugger.png|width=80|label=SmaccSpecialDebugger+


!!! Understand Smacc Errors

!!!! shift/reduce conflicts

!!!! Reduce/reduce conficts





!!! Unit testing

Often you would like to test productions that are not top productions. This is really useful to validate every part of the grammar individually and to have non-regression tests while building your parser. In this case, you should add start symbol that specify that we can access different productions. 
For example if you add the following to an hypothetical grammar:

[[[
%start file expression statement declaration;
]]]

SmaCC will generate the following class methods on the parser: ==startingStateForfile==, ==startingStateForexpression==, ==startingStateForstatement== and ==startingStateFordeclaration==.

You can then invoke your parser on your program using a specific starting state. Since you want to reuse this behaviour, you can either put it in ==YourParserTest== class as a support method:

[[[
YourParserTest >> parseExpressionTest: aString
	((YourParser on: (ReadStream on: aString)) setStartingState: YourParser startingStateForexpression) parse.
]]]

Or, if you do not want to duplicate the logic in your tests you can extend the parser itself as follows. It is a design decision that is up to you.

[[[
YourParser >> parseExpression: aString
	"Parse an expression."

	^ (self on: (ReadStream on: aString))
		setStartingState: self startingStateForexpression;
		parse
]]]

!!! Parsing indentation dependent languages





!!! Tips and Tricks 

Sometimes you might have a grammar for your language that is for another type of parser generator (ANTLR for example) and want to convert it to the SmaCC format. 

!!!! Fusion

In LL(k) parsers, the lookahead can be increased, which is not the case for the LR(1)/LALR(1) of SmaCC. You can encounter some problems when converting your grammar, since it will be ambiguous.
A simple trick that can work in some cases is merging multiple tokens into a single one.
For example, for the Solidity parser we had ambiguities for the key-value pairs.

Simplified ambiguous version:

[[[
Expression
    : Expression ("," Expression)* 
    | <id> ;

KeyValueList
    : <id> ":" Expression ("," <id> ":" Expression)* ;
]]]

Simplified fused version:

[[[
<idkey>: , <id> : ;
KeyValueList
    : <id> ":" Expression (<idkey> Expression)* ;
]]]

!!!! identifier vs. type


